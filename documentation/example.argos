<?xml version="1.0" ?>

<argos-configuration>
	<!-- Interal parameters of ARGoS itself -->
	<framework>
		<!--
			- threads: the number of slave threads to parallelize the computation.
				Exceeding the number of CPU cores (not CPU threads!) will result in a performance hit.
			- method: the task assignment method for the threads.
				- balance_quantity: divides the number tasks evenly among the threads.
					Best used for homogeneous swarms.
				- balance_length: a thread fetches a new task every time it is idle.
					Best used for heterogeneous swarms.
		-->
		<system threads="0"
				method="balance_quantity" />

		<!--
			- length: the time limit of the experiment in seconds.
				Zero means no time limit.
			- ticks_per_second: how many times per second the simulation step is executed.
				See also CCI_Controller::ControlStep().
			- random_seed: the seed for the random number generator.
				Zero means that the internal clock time is used.
				Setting a specific value is necessary to obtain the same results across repetitions.
		-->
		<experiment length="0"
					ticks_per_second="10"
					random_seed="12345" />

		<!--
			- file: the file in which RAM and CPU usage data is written.
			- format:
				- human_readable: meant as easy-to-read.
				- table: meant as easy-to-parse.
			- trunate:
				- true: the file is overwritten every time the simulation is rerun.
				- false: the data will be appended to the file.
		-->
		<profiling file=""
				   format=""
				   truncate_file="" />
	</framework>

	<!-- Robot controllers to use -->
	<controllers>
		<!--
			Each controller is identified by a user-defined tag and some attributes.
			- id: a unique identifier for this controller, to distinguish between different configurations of the same controller type.
			- library: the path to the compiled library that contains the code.
		-->
		<my_controller id="my_id"
					   library="/path/to/libmy_controller.so">
			<!--
				Actuators modify the sate of the robot or of the environment.
				For a list of the possible actuators, type at the command prompt:
				$ argos3 -q actuators
			-->
			<actuators>
			</actuators>

			<!--
				Sensors read states of other robots or of the environment.
				For a list of the possible sensors, type at the command prompt:
		  		$ argos3 -q sensors
			-->
			<sensors>
			</sensors>

			<!--
				User-defined XML tags to configure the controller.
				See also CCI_Controller::Init().
			-->
			<params />
		</my_controller>
	</controllers>

	<!--
		Entities to add to the arena at the beginning of the experiment.
		Position coordinates are in the X,Y,Z order.
		Orientation angles are in the Z,Y,X order and uses degrees!
		For a list of the possible entities, type at the command prompt:
		$ argos3 -q entities
		To get help about a specific entity, type at the command prompt:
		$ argos3 -q entity_name
		- size: the size of the arena in 3 dimensions around the origin.
		- center: the center of the grid in 3 dimensions, to be used with the grid distribution method.
		- positional_grid_size: the size of the grid in 3 dimensions, to be used with the grid distribution method.
	-->
	<arena size="2,2,1"
		   center=""
		   positional_grid_size="">
		<!--
		It is also possible to distribute objects automatically using the distribute tag.
		-->
		<distribute>
			<!--
				How positions are generated for each entity to distribute.
				- method:
					- uniform: uses a uniform distribution. Additional attributes 'min' and 'max'.
					- gaussian: uses a gaussian distribution. Additional attributes 'mean' and 'std_dev'.
					- constant: uses a constant value. Additional attribute 'values' as a x,y,z triplet.
					- grid: places entities on a grid. Additional attributes 'center', 'distances' and 'layout'.
			-->
			<position method="" />

			<!--
				How orientations are generated for each entity to distribute.
				Same attributes as position.
			-->
			<orientation method="" />

			<!--
				The type of entity to distribute.
				- quantity: how many entities to use.
				- max_trials: the maximum number of placing attempts before throwing an error.
				The 'id' specified for the entity type is used as a prefix for the added entities.
				The 'base_num' attribute sets the base number for this id and defaults to zero.
			-->
			<entity quantity=""
					max_trials="">
			</entity>
		</distribute>
	</arena>

	<!--
		Which physics engines to use and how they connect to each other.
		For a list of the possible engines, type at the command prompt:
		$ argos3 -q physics_engines
	-->
	<physics_engines>
		<!--
			A 2 dimensional physics engine.
			- id: a unique identifier for this physics engine, to distinguish between different configurations of the same physics engine type.
			- iterations: the amount of iterations this physics engine performs between 2 simulation steps.
			- elevation: change the Z axis of this physics engine, to simulate for example hovering objects.
			For swarms with <= 50 robots in a small arena, a single physics engine suffices.
			Use the same number of threads as there are physics engines.
		-->
		<dynamics2d id="dyn2d"
					iterations="10"
					elevation="0.0">
			<!--
				Friction parameters between the ground and movable boxes and cylinders.
			-->
			<friction box_linear_friction="1.49"
					  box_angular_friction="1.49"
					  cylinder_linear_friction="1.49"
					  cylinder_angular_friction="1.49" />
		</dynamics2d>
	</physics_engines>

	<!--
		Media to use for communication.
		For a list of the possible media, type at the command prompt:
		$ argos3 -q media
	-->
	<media>
	</media>

	<!--
		Visualization set up, i.e. the windows that shows when running the experiment.
		For a list of the possible visualizations, type at the command prompt:
		$ argos3 -q visualizations
	-->
	<visualization>
		<!--
			An interactive graphical renderer based on QT and OpenGL.
			- autoplay: whether to start the simulation at startup.
		-->
		<qt-opengl autoplay="false">
			<!--
				Set up to 12 different camera positions.
				- idx: the camera index and key to press to switch to that camera.
				- position: the position of the camera in the arena.
				- look_at: the point the camera is looking at.
				- up: to prevent ambiguous camera placement, also specify the camera up vector.
				- lens_focal_length: the focal length of the lens in millimeters.
				- frame_diagonal: the length of the frame diagonal of the image film in millimeters.
			-->
			<camera>
				<placement idx="0"
						   position="0,0,16"
						   look_at="0,0,0"
						   up="0,1,0"
						   lens_focal_length="20"
						   frame_diagonal="35" />
			</camera>

			<!--
				Configuration when grabbing frames and storing them into image files.
				- directory: the directory where to store the frames.
					This directory must exist and be writable.
				- base_name: the string to prepend to the file name, after which the frame number is added.
				- format: the file format to use.
				- quality: the quality of the image ranging from 0 (max compression) to 100 (no compression).
					For screenshots, it's best to use -1, which uses Qt's default quality.
					For videos, it's best to use 100, to avoid artifacts due to compression.
				- headless_grabbing: whether to grab frames when running ARGoS without visualizations.
				- headless_frame_size: the size of the main QTWidget in ARGoS, not the size of the converted frames when running ARGoS without visualizations.
				- headless_frame_rate: the frame skip rate (i.e. grab every nth frame) when running ARGoS without visualizations.
			-->
			<frame_grabbing directory="/path/to/frame_directory"
            				base_name="frame_"
							format="png"
							quality="100"
							headless_grabbing="false"
							headless_frame_size="1920x1080"
							headless_frame_rate="1" />

			<!--
				User functions, which are a set of visualization hook functions that are executed during the main loop.
				- library: the path to the library where the user functions are stored.
				- label: the user function class to use.
					In this way, in a single library you can have multiple user function implementations.
			-->
			<user_functions library="/path/to/libmy_user_functions.so"
							label="my_user_functions" />
		</qt-opengl>
	</visualization>

	<!--
		Loop functions, which are a set of hook functions that are executed during the main loop.
		- library: the path to the library where the loop functions are stored.
		- label: the loop function class to use.
			In this way, in a single library you can have multiple loop function implementations.
	-->
	<loop_functions library="/path/to/libmy_loop_functions.so"
					label="my_loop_functions" />
</argos-configuration>